from copy import deepcopy
from itertools import chain

import numpy as np

try:
    import IPython
except ImportError:
    has_ipython = False
else:
    has_ipython = True
    from IPython.html import widgets
    from IPython.display import HTML, display, clear_output
    from IPython.utils.traitlets import link

def build_param_widget(p):
    if p.value is not None:
        param_widget = widgets.FloatText(description=p.name, value=p.value, min=p.min, max=p.max)
    else:
        param_widget = widgets.FloatText(description=p.name, min=p.min, max=p.max)
    return param_widget

class Fitter(object):
    """This an interactive container for fitting a Model to particular data.

    It maintains the attributes `current_params` and `current_result`. When
    its fit() method is called, the best fit becomes the new `current_params`.
    The most basic usage is iteratively fitting data, taking advantage of
    this stateful memory that keep the parameters between each fit.

    If matplotlib as available, a plot is generated by fit(), showing the
    data, the initial guess, and the best fit.

    If IPython is available, it uses the IPython notebook's rich display
    to fit data interactively in a web-based GUI. The Parameters are
    represented in a web-based form that is kept in sync with `current_params`. 
    Clicking the "Fit" button updates a plot, as above, and updates the
    Parameters in the form to reflect the best fit.
    
    Examples
    --------
    >>> fitter = Fitter(model, data, x=x)
    # In the IPython notebook, this displays a form with text
    # fields for each Parameter in the model and a "Fit" button.
    
    >>> fitter.current_params
    # This copy of the model's Parameters is updated after each fit.
    # In the IPython notebook ,it is always in sync with
    # the current values entered into the text fields.
    
    >>> fitter.fit()
    # Perform a fit using fitter.current_params as a guess.
    # Optionally, pass a params argument or individual keyword arguments
    # to override current_params. This method can also be called by clicking
    # the "Fit" button in the web form.
    
    >>> fitter.current_result
    # This is the result of the latest fit. It contain the usual
    # copies of the Parameters, in the attributes params and init_params.
    """
    def __init__(self, model, data, **kwargs):
        self.model = model
        self.data = data
        self.kwargs = kwargs
        self.current_result = None
        self._current_params = None
        if has_ipython:
            self.fit_button = widgets.Button(description='Fit')
            self.fit_button.on_click(self._on_button_click)
            self.param_widgets = [build_param_widget(p)
                                  for _, p in self.current_params.items()]
        
    @property
    def current_params(self):
        """Each time fit() is called, these will be updated to reflect
        the latest best params. They will be used as the initial guess
        for the next fit, unless overridden by arguments to fit()."""
        if self._current_params is None:
            self._current_params = self.model.make_params()
        elif has_ipython:
            for pw in self.param_widgets:
                self._current_params[pw.description].value = pw.value
        return self._current_params
            
    def _update_param_widgets(self):
        for pw in self.param_widgets:
            pw.value = self._current_params[pw.description].value
            
    def _on_button_click(self, b):
        self.fit()
        
    def fit(self, *args, **kwargs):
        "Use current_params unless overridden by arguments passed here."
        guess = dict(self.current_params)
        guess.update(self.kwargs)  # from __init__, e.g. x=x
        guess.update(kwargs)
        self.current_result = self.model.fit(self.data, *args, **guess) 
        self._current_params = self.current_result.params
        self._update_param_widgets()
        self.plot()
        
    def plot(self):
        try:
            import matplotlib.pyplot as plt
        except ImportError:
            pass
        if has_ipython:
            clear_output(wait=True)
        fig, ax = plt.subplots()
        count_indep_vars = len(self.model.independent_vars)
        if count_indep_vars == 0:
            ax.plot(self.data)
        elif count_indep_vars == 1:
            indep_var = self.kwargs[self.model.independent_vars[0]]
            ax.plot(indep_var, self.data, marker='o', linestyle='none')
        else:
            raise NotImplementedError("Cannot plot models with more than one "
                                      "indepedent variable.")
        result = self.current_result  # alias for brevity
        if not result:
            return  # short-circuit the rest of the plotting
        if count_indep_vars == 0:
            ax.plot(result.init_fit, color='gray')
            ax.plot(result.best_fit, color='red')
        elif count_indep_vars == 1:
            ax.plot(indep_var, result.init_fit, color='gray')
            ax.plot(indep_var, result.best_fit, color='red')
            
    def _repr_html_(self):
        for pw in self.param_widgets:
            display(pw)
        display(self.fit_button)
        self.plot()
